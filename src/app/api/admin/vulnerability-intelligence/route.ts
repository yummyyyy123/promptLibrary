import { NextRequest, NextResponse } from 'next/server'
import { withAdminAuth } from '@/lib/admin-auth'

interface GitHubAdvisory {
  ghsa_id: string
  severity: string
  summary: string
  description: string
  published_at: string
  modified_at: string
  vulnerabilities: Array<{
    package: {
      name: string
      ecosystem: string
    }
    severity: string
    vulnerable_version_range: string
    first_patched_version?: string
  }>
  cvss: {
    score: number
    vector_string: string
  }
}

interface VulnerabilityMatch {
  advisory: GitHubAdvisory
  affectedPackage: string
  currentVersion: string
  severity: string
  cvssScore: number
  recommendedAction: string
}

export const GET = withAdminAuth(async (request: NextRequest) => {
  try {
    console.log('üîç Fetching vulnerability intelligence...')

    // Fetch latest advisories from GitHub Advisory Database
    const githubResponse = await fetch('https://api.github.com/advisories?ecosystem=npm&per_page=50&sort=published&direction=desc', {
      headers: {
        'Accept': 'application/vnd.github.v3+json',
        'User-Agent': 'Security-Intelligence-System'
      }
    })

    if (!githubResponse.ok) {
      throw new Error(`GitHub API error: ${githubResponse.status}`)
    }

    const advisories: GitHubAdvisory[] = await githubResponse.json()
    console.log(`üìä Fetched ${advisories.length} advisories`)

    // Get current project dependencies
    const packageJson = await getPackageDependencies()
    const vulnerablePackages = await matchVulnerabilities(advisories, packageJson)

    console.log(`‚ö†Ô∏è Found ${vulnerablePackages.length} vulnerable packages`)

    return NextResponse.json({
      success: true,
      timestamp: new Date().toISOString(),
      totalAdvisories: advisories.length,
      vulnerablePackages: vulnerablePackages,
      securityHealthScore: calculateSecurityScore(vulnerablePackages),
      lastUpdated: new Date().toISOString()
    })

  } catch (error: any) {
    console.error('‚ùå Vulnerability intelligence error:', error)
    return NextResponse.json(
      {
        error: 'Failed to fetch vulnerability intelligence',
        details: error.message,
        timestamp: new Date().toISOString()
      },
      { status: 500 }
    )
  }
})

async function getPackageDependencies(): Promise<Record<string, string>> {
  try {
    const fs = await import('fs/promises')
    const path = await import('path')

    const packageLockPath = path.join(process.cwd(), 'package-lock.json')
    const packageLockContent = await fs.readFile(packageLockPath, 'utf-8')
    const packageLock = JSON.parse(packageLockContent)

    // Extract dependencies and their versions
    const dependencies: Record<string, string> = {}

    if (packageLock.packages) {
      Object.entries(packageLock.packages).forEach(([name, info]: [string, any]) => {
        if (name !== '' && info.version) {
          // Extract package name from path (e.g., "node_modules/package-name" -> "package-name")
          const packageName = name.includes('node_modules/') ? name.split('node_modules/')[1] : name
          dependencies[packageName] = info.version
        }
      })
    }

    console.log(`üì¶ Found ${Object.keys(dependencies).length} dependencies`)
    return dependencies

  } catch (error) {
    console.error('‚ùå Error reading package-lock.json:', error)
    return {}
  }
}

async function matchVulnerabilities(advisories: GitHubAdvisory[], dependencies: Record<string, string>): Promise<VulnerabilityMatch[]> {
  const matches: VulnerabilityMatch[] = []

  for (const advisory of advisories) {
    for (const vulnerability of advisory.vulnerabilities) {
      if (vulnerability.package.ecosystem === 'npm') {
        const packageName = vulnerability.package.name

        // Check if this package is in our dependencies
        if (dependencies[packageName]) {
          const currentVersion = dependencies[packageName]

          // Check if current version is vulnerable
          if (isVersionVulnerable(currentVersion, vulnerability.vulnerable_version_range)) {
            matches.push({
              advisory,
              affectedPackage: packageName,
              currentVersion,
              severity: vulnerability.severity || advisory.severity,
              cvssScore: advisory.cvss?.score || 0,
              recommendedAction: generateRecommendedAction(vulnerability, currentVersion)
            })
          }
        }
      }
    }
  }

  return matches.sort((a, b) => b.cvssScore - a.cvssScore) // Sort by severity
}

function isVersionVulnerable(currentVersion: string, vulnerableRange: string): boolean {
  // Simple version range matching (can be enhanced with semver library)
  if (vulnerableRange.includes('*')) {
    return true // Wildcard match
  }

  if (vulnerableRange.includes('>=') || vulnerableRange.includes('<=') || vulnerableRange.includes('<') || vulnerableRange.includes('>')) {
    // For now, assume vulnerability if range contains operators
    // In production, use semver.satisfies() for accurate matching
    return true
  }

  // Exact version match
  return currentVersion === vulnerableRange
}

function generateRecommendedAction(vulnerability: any, currentVersion: string): string {
  if (vulnerability.first_patched_version) {
    return `Update ${vulnerability.package.name} from ${currentVersion} to ${vulnerability.first_patched_version.identifier}`
  }

  return `Review and update ${vulnerability.package.name} (current: ${currentVersion})`
}

function calculateSecurityScore(vulnerabilities: VulnerabilityMatch[]): number {
  if (vulnerabilities.length === 0) return 100

  let totalScore = 100

  vulnerabilities.forEach(vuln => {
    if (vuln.cvssScore >= 9.0) {
      totalScore -= 30 // Critical
    } else if (vuln.cvssScore >= 7.0) {
      totalScore -= 20 // High
    } else if (vuln.cvssScore >= 4.0) {
      totalScore -= 10 // Medium
    } else {
      totalScore -= 5 // Low
    }
  })

  return Math.max(0, totalScore)
}
